# 被动扫描模式修复总结

## 问题概述

被动扫描模式存在以下关键问题：
1. **Cookie和认证状态复用不可靠**：浏览器池无法正确保持和同步认证状态
2. **竞态条件**：导航事件和交互事件处理存在时序问题
3. **存储注入失败**：LocalStorage和SessionStorage注入在某些情况下会失败
4. **缺乏持久化**：认证状态没有持久化，浏览器重启后丢失

## 修复方案

### 1. 增强的浏览器池 (BrowserPool)

#### 1.1 持久化认证状态管理
- 新增 `PersistentAuthState` 类，支持按域名存储认证状态
- 自动保存到磁盘 (`./auth_states/` 目录)
- 支持全局状态和域名特定状态

#### 1.2 实时状态同步
- `AuthSynchronizer` 新增 `sync_on_navigation()` 方法
- 导航时立即同步状态，而不是仅依靠定时同步
- 防止频繁同步的最小间隔控制

#### 1.3 域名特定上下文
- 新增 `create_context_for_domain()` 方法
- 为每个域名创建具有特定认证状态的上下文
- 避免跨域cookie污染

### 2. 增强的认证状态注入 (auth_tools.py)

#### 2.1 域名验证
- 注入cookie时验证域名匹配
- 支持通配符域名 (`.example.com`)
- 过滤不适用当前域的cookie

#### 2.2 重试机制
- 注入失败时自动重试（最多3次）
- 等待页面加载完成后再注入
- 详细的错误报告

#### 2.3 导航后重试
- `inject_with_retry_on_navigation()` 方法
- 监听页面响应，在导航后重试注入
- 处理单页应用路由变化

### 3. 修复竞态条件 (investigation_manager.py)

#### 3.1 延迟清理交互链
- 使用 `_delayed_clear_interaction_chain()` 延迟2秒清理
- 给正在进行的交互分析时间完成
- 避免状态丢失

#### 3.2 优化事件处理顺序
- 先同步认证状态，再清理交互链
- 确保状态更新不被中断

### 4. 更新的交互工作流 (interaction_worker.py)

#### 4.1 智能上下文选择
- 优先使用域名特定上下文
- 回退到通用池化上下文
- 正确处理上下文生命周期

#### 4.2 增强的状态注入
- 使用新的重试机制
- 设置导航后重试监听器
- 改进错误处理

## 使用建议

1. **配置浏览器池模式**：
   - `shared`: 共享主浏览器上下文（资源效率高）
   - `standalone`: 独立浏览器实例（隔离性好）

2. **调整同步间隔**：
   ```yaml
   browser_pool:
     periodic_sync_interval: 30  # 秒
     realtime_check_interval: 2  # 实时检查间隔
   ```

3. **监控日志**：
   - 关注 "认证状态注入成功/失败" 消息
   - 查看 "同步认证状态" 日志
   - 监控浏览器池状态

## 技术细节

### Cookie处理流程
1. 从主浏览器提取完整状态
2. 验证cookie域名匹配
3. 注入有效cookie
4. 重试失败的注入
5. 监听导航事件并重试

### 状态持久化
- 全局状态：`./auth_states/global_state.json`
- 域名状态：`./auth_states/{domain}.json`
- 自动加载和保存

### 性能优化
- 最小同步间隔防止过度同步
- 域名特定上下文减少cookie污染
- 智能重试机制减少无效操作

这些修复确保了被动扫描模式能够可靠地复用浏览器的cookie和认证状态，显著提升了状态化分析的准确性。